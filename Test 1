/* Чтобы определить процедуру PostgreSQL, которая отправляет уведомления по электронной почте, я  использую  функции: 
isWorkDay(date) - возвращает истину, если день рабочий, 
getNextWorkDay(date) - возвращает дату следующего рабочего дня и  
sendMessage(email, text) - отправка сообщений */


-- Функция для определения рабочего дня
CREATE OR REPLACE FUNCTION isWorkDay(date timestamp with time zone) 
  RETURNS boolean AS $$
DECLARE
  day_type text;
BEGIN
	-- Проверяет, является ли дата будним днём или выходным
  SELECT CASE WHEN EXTRACT(ISODOW FROM current_timestamp) BETWEEN 1 AND 5 THEN 'weekday' ELSE 'weekend' END INTO day_type; 
  IF day_type = 'weekday' THEN
	-- Проверяет, не является ли дата праздничным днем
    RETURN NOT EXISTS(SELECT 1 FROM holidays WHERE current_timestamp = date); 
  ELSE
    RETURN false;
  END IF;
END;
$$ LANGUAGE plpgsql;

	-- Создание таблицы Праздничных дней
CREATE TABLE holidays (
  date date PRIMARY KEY
);

INSERT INTO holidays (date)
VALUES
    ('2023-01-01'), -- Новый год
    ('2023-01-07'), -- Рождество Христово (православное)
    ('2023-02-23'), -- День защитника Отечества
    ('2023-03-08'), -- Международный женский день
    ('2023-05-01'), -- Праздник Весны и Труда
    ('2023-05-09'), -- День Победы
    ('2023-06-12'), -- День России
    ('2023-11-04'), -- День народного единства
    ('2023-12-31'); -- Новогодний выходной день

	-- Функция для получения даты следующего рабочего дня
CREATE OR REPLACE FUNCTION getNextWorkDay(date timestamp with time zone) 
  RETURNS date AS $$
DECLARE
  next_day date := current_timestamp + INTERVAL '1 day';
BEGIN
  WHILE NOT isWorkDay(next_day) LOOP
    next_day := next_day + INTERVAL '1 day';
  END LOOP;
  RETURN next_day;
END;
$$ LANGUAGE plpgsql;


	--Функция для отправки сообщений
CREATE OR REPLACE FUNCTION sendMessage(email text, text text)
  RETURNS void AS $$
DECLARE
  command text;
BEGIN
  command := format(text, email);
  EXECUTE command;
END;
$$ LANGUAGE plpgsql;

	-- Создание таблицы Договора с параметрами: 
  -- номер договора, дату начала, дату окончания, адрес электронной почты ответственного сотрудника и адрес электронной почты бухгалтера

CREATE TABLE contracts (
  contract_number VARCHAR(50),
  start_date DATE,
  end_date DATE,
  responsible_employee_email VARCHAR(100),
  accountant_email VARCHAR(100)
);

INSERT INTO contracts (contract_number,start_date,end_date,responsible_employee_email,accountant_email)
VALUES
    ('1234','2023-07-01', '2023-07-15','responsible_employee@mail.ru', 'accountant@email.ru'), 
    ('1241','2023-07-15', '2023-07-25','responsible_employee@mail.ru', 'accountant@email.ru'); 
	


CREATE OR REPLACE PROCEDURE sendContractNotifications()
LANGUAGE plpgsql
AS $$
DECLARE
  contract_row RECORD;
  date timestamp with time zone := CURRENT_DATE;
  notification_date_7 DATE;
  notification_date_14 DATE;
BEGIN
  -- Рассчитываем даты уведомлений
  notification_date_7 := getNextWorkDay(current_date + INTERVAL '7 days');
  notification_date_14 := getNextWorkDay(current_date + INTERVAL '14 days');

  -- Получаем договора, которые истекают через 7 и 14 дней
  FOR contract_row IN (
    SELECT
      contract_number,
      start_date,
      end_date,
      responsible_employee_email,
      accountant_email
    FROM
      contracts
    WHERE
      end_date = notification_date_7 OR end_date = notification_date_14
  ) LOOP
    -- Проверяем, является ли дата уведомления рабочим днём
	
	IF NOT isWorkDay(contract_row.end_date) THEN
	contract_row = getNextWorkDay(contract_row.end_date);
	END IF;
  
      -- Составляем электронное сообщение
      PERFORM sendMessage(contract_row.responsible_employee_email, format('Срок действия договора %s is expiring on %s.', contract_row.contract_number, contract_row.end_date));
      PERFORM sendMessage(contract_row.accountant_email, format('Срок действия договора %s is expiring on %s.', contract_row.contract_number, contract_row.end_date));
    END LOOP;
END;
$$;

	-- Проверка
CALL sendContractNotifications();

SELECT getNextWorkDay(timestamp with time zone '2023-07-01');
SELECT isWorkDay(date '2023-07-03');
	
	
