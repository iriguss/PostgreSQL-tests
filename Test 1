/* Чтобы определить процедуру PostgreSQL, которая отправляет уведомления по электронной почте, я использую функции: 
isWorkDay(date) - возвращает истину, если день рабочий, 
getNextWorkDay(date) - возвращает дату следующего рабочего дня и 
sendMessage(email, text) - отправка сообщений */


-- Функция для определения рабочего дня
СОЗДАТЬ или ЗАМЕНИТЬ ФУНКЦИЮ isWorkDay (временная метка даты с часовым поясом) 
 ВОЗВРАЩАЕТ логическое ЗНАЧЕНИЕ В ВИДЕ $$
ОБЪЯВИТЬ
 day_type текст;
НАЧИНАЮТСЯ
 -- Проверяет, является ли дата будним днём или выходным
 ВЫБЕРИТЕ СЛУЧАЙ, КОГДА ИЗВЛЕЧЕНИЕ (ISODOW ИЗ current_timestamp) МЕЖДУ 1 И 5, ЗАТЕМ 'weekday', ИНАЧЕ 'weekend' ЗАКАНЧИВАЕТСЯ В day_type; 
 ЕСЛИ day_type = 'день недели', ТО
 -- Проверяет, не является ли дата праздничным днем
 ВОЗВРАТ НЕ СУЩЕСТВУЕТ (ВЫБЕРИТЕ 1 ИЗ списка праздников, ГДЕ current_timestamp = дата); 
 ещё
 ВОЗВРАЩАЕТ false;
 ЗАВЕРШАЮТСЯ, ЕСЛИ;
ЗАВЕРШЕНИЕ;
$$ ЯЗЫК plpgsql;

 -- Создание таблицы Праздничных дней
СОЗДАТЬ ТАБЛИЦУ праздников (
 дата ПЕРВИЧНОГО КЛЮЧА
);

ВСТАВИТЬ В праздничные дни (дата)
ЗНАЧЕНИЯ
 ('2023-01-01'), -- Новый год
 ('2023-01-07'), -- Рождество Христово (православное)
 ('2023-02-23'), -- День защитника Отечества
 ('2023-03-08'), -- Международный женский день
 ('2023-05-01'), -- Праздник Весны и Труда
 ('2023-05-09'), -- День Победы
 ('2023-06-12'), -- День России
 ('2023-11-04'), -- День народного единства
 ('2023-12-31'); -- Новогодний выходной день

 -- Функция для получения даты следующего рабочего дня
СОЗДАЙТЕ Или ЗАМЕНИТЕ ФУНКЦИЮ getNextWorkDay (временная метка даты с часовым поясом) 
 ВОЗВРАЩАЕТ дату В ВИДЕ $$
ОБЪЯВИТЬ
 дата следующего дня: = отметка текущего времени + ИНТЕРВАЛ '1 день';
НАЧИНАЮТСЯ
 ПОКА НЕ является рабочим днем (next_day) ЦИКЛ
 следующий день := следующий день + ИНТЕРВАЛ '1 день';
 ЗАВЕРШИТЬ ЦИКЛ;
 ВЕРНИТЕСЬ на следующий день;
ЗАВЕРШЕНИЕ;
$$ ЯЗЫК plpgsql;


 --Функция для отправки сообщений
СОЗДАТЬ Или ЗАМЕНИТЬ ФУНКЦИЮ SendMessage (текст электронного письма, текстовый текст)
 ВОЗВРАЩАЕТ ЗНАЧЕНИЕ void В ВИДЕ $$
ОБЪЯВИТЬ
 текст команды;
НАЧИНАЮТСЯ
 команда:= форматировать (текст, электронное письмо);
 ВЫПОЛНИТЬ команду;
ЗАВЕРШЕНИЕ;
$$ ЯЗЫК plpgsql;

 -- Создание таблицы Договора с параметрами: 
 -- номер договора, дату начала, дату окончания, адрес электронной почты ответственного сотрудника и адрес электронной почты бухгалтера

СОЗДАНИЕ ТАБЛИЧНЫХ контрактов (
 переменная с номером контракта (50),
 start_date ДАТА,
 дата окончания,
 переменная responsible_employee_email(100),
 переменная accountant_email(100)
);

ВСТАВКА В контракты (contract_number,start_date,end_date,responsible_employee_email,accountant_email)
ЗНАЧЕНИЯ
 ('1234','2023-07-01', '2023-07-15','responsible_employee@mail.ru ', 'accountant@email.ru '), 
 ('1241','2023-07-15', '2023-07-25','responsible_employee@mail.ru ', 'accountant@email.ru '); 



СОЗДАЙТЕ Или ЗАМЕНИТЕ ПРОЦЕДУРУ sendContractNotifications()
ЯЗЫК plpgsql
КАК $$
ОБЪЯВИТЬ
 запись contract_row;
 временная метка даты с часовым поясом:= CURRENT_DATE;
 дата уведомления_date_7;
 дата уведомления_14;
НАЧИНАЮТСЯ
 -- Рассчитываем даты уведомлений
 notification_date_7 := getNextWorkDay (текущая дата + ИНТЕРВАЛ '7 дней');
 notification_date_14 := getNextWorkDay (текущая дата + ИНТЕРВАЛ '14 дней');

 -- Получаем договора, которые истекают через 7 и 14 дней
 ДЛЯ contract_row В (
 ВЫБЕРИТЕ
 contract_number,
 start_date,
 дата окончания,
 ответственный_задание_почты,
 accountant_email
 От
 контракты
 ГДЕ
 end_date = notification_date_7 ИЛИ end_date = notification_date_14
 ) ЦИКЛ
 -- Проверяем, является ли дата уведомления рабочим днём

 ЕСЛИ НЕ является рабочим днем (contract_row.end_date) ТОГДА
 contract_row = getNextWorkDay(contract_row.end_date);
 ЗАВЕРШАЮТСЯ, ЕСЛИ;

 -- Составляем электронное сообщение
 ВЫПОЛНИТЕ отправку сообщения(contract_row.responsible_employee_email, формат('срок действияСрок действия договора %s истекает в %s.', contract_row.contract_number, contract_row.end_date));
 ВЫПОЛНИТЕ отправку сообщения(contract_row.accountant_email, формат('срок действияСрок действия договора %s истекает в %s.', contract_row.contract_number, contract_row.end_date));
 ЗАВЕРШИТЬ ЦИКЛ;
ЗАВЕРШЕНИЕ;
$$;

 -- Проверка
ВЫЗОВИТЕ sendContractNotifications();

ВЫБЕРИТЕ getNextWorkDay (временная метка с часовым поясом '2023-07-01');
ВЫБЕРИТЕ isWorkDay (дата '2023-07-03');
